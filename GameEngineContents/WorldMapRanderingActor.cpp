#include "PreCompile.h"
#include "WorldMapRanderingActor.h"

WorldMapRanderingActor::WorldMapRanderingActor()
	: tileSize_(256.f),
	windowSize_(GameEngineWindow::GetScale()),
	tileCountXY_(8.0f ,10.f),
	tileCount_(tileCountXY_.IX()* tileCountXY_.IY()),
	worldRenderer_(nullptr)
{
}

WorldMapRanderingActor::~WorldMapRanderingActor()
{
}

void WorldMapRanderingActor::Start()
{
	
}

void WorldMapRanderingActor::Update(float _deltaTime)
{
	float4 thisWorldPosition = this->GetTransform().GetWorldPosition();
	UpdateFieldObjectInfos(thisWorldPosition);
}

void WorldMapRanderingActor::End()
{
}

void WorldMapRanderingActor::Initialize(
	size_t _totalFieldObjectCount,
	size_t _objectInWindowCount
)
{
	InitializeFieldObjects(_totalFieldObjectCount, _objectInWindowCount);
	InitializeFieldRenderer(_objectInWindowCount);
}

void WorldMapRanderingActor::InitializeFieldObjects(
	size_t _totalFieldObjectCount,
	size_t _objectInWindowCount
)
{
	
	worldObjectAtlasDatas_.resize(8);

	//나무 .
	worldObjectAtlasDatas_[0].SetData(AtlasData(0.f, 0.f, 1.f, 0.5f, 0.f, 0.0f));

	allWorldObjectDataVector_.reserve(_totalFieldObjectCount);

	renderingFieldObjectDataVector_.reserve(_objectInWindowCount);

	
	for (size_t y = 0; y < 2; y++)
	{
		for (size_t x = 0; x < 2 * y + 1; x++)
		{
			//필드오브젝트 배치 구간.
			float4 tilePos = this->GetTransform().GetWorldPosition();
			float Ranf = GameEngineRandom::mainRandom_.RandomFloat(10.f, 30.f);
			float RanfX = GameEngineRandom::mainRandom_.RandomFloat(10.f, 50.f);
			tilePos.x += 64.f + x * 64.f - 64.f * y + RanfX;
			tilePos.y += (0 - 64.f * y) * sinf(10.f * GameEngineMath::DegreeToRadian) + 64.f;
			tilePos.z += (0 - 64.f * y) * cosf(10.f * GameEngineMath::DegreeToRadian);


			float4 worldScale = float4(256.f, 128.f);

			allWorldObjectDataVector_.push_back(
				WorldObjectData(
					tilePos,
					worldScale,
					0
				)
			);
		}
	}
}

void WorldMapRanderingActor::InitializeFieldRenderer(size_t _objectInWindowCount)
{
	worldRenderer_ = GetLevel()->GetMainCamera()->GetInstancingRenderer("WorldRenderer");
	worldRenderer_->Initialize(
		static_cast<size_t>(tileCount_) + _objectInWindowCount,
		"Rect",
		"MultiTexturesInstancing"
	);
	worldRenderer_->SetTexture2DArray("Inst_Textures", "Field");
	worldRenderer_->SetSampler("POINTCLAMP", "POINTCLAMP");
	//fieldRenderer_->SetAllUnitsWorldScale(256, 256, 1);
	//그려질 필요없는 렌더유닛들이 256, 256 크기로 그려지는 버그 발생.

	int unitIndex = 0;
	for (int y = 0; y < tileCountXY_.IY(); ++y)
	{
		for (int x = 0; x < tileCountXY_.IX(); ++x)
		{
			float4 tilePos = this->GetTransform().GetWorldPosition();
			tilePos.x += x * tileSize_;
			tilePos.y += -tileSize_ * sinf(10.f * GameEngineMath::DegreeToRadian) * y;
			tilePos.z += -tileSize_ * cosf(10.f * GameEngineMath::DegreeToRadian) * y;

			worldRenderer_->GetInstancingUnit(unitIndex).GetAtlasData().SetData(0.f, 0.f, 1.f, 1.f, 0.f, 0.0f);
			//NewGrassTexture.png 전체를 다 그린다.

			worldRenderer_->GetInstancingUnit(unitIndex).SetTextureIndex(2);
			//NewGrassTexture.png는 2번으로 삽입되어 있다.

			worldRenderer_->GetInstancingUnit(unitIndex).SetWorldScale(tileSize_, tileSize_, 1.f);
			//타일을 그리는 인스턴싱유닛들만 크기 설정을 해준다.

			worldRenderer_->GetInstancingUnit(unitIndex).SetWorldPosition(tilePos);	//타일 렌더하는 인스턴싱유닛들의 위치 설정.

			worldRenderer_->GetInstancingUnit(unitIndex).SetWorldRotation(float4(80.f,0.f,0.f));

			++unitIndex;
		}
	}
}


void WorldMapRanderingActor::UpdateFieldObjectInfos(const float4& _thisWorldPosition)
{
	renderingFieldObjectDataVector_.clear();
	//뭐가 들어있든지 일단 전부 비운다. 
	//capacity는 변하면 안된다.
	float4 CameraPos = GetLevel()->GetMainCamera().get()->GetTransform().GetWorldPosition() - float4(640.f, -360.f);

	for (WorldObjectData& singleObjectData : allWorldObjectDataVector_)
	{
		if (singleObjectData.worldPosition_.x > CameraPos.x + 1280.f)
		{
			continue;
		}
		else if (singleObjectData.worldPosition_.x < CameraPos.x)
		{
			continue;
		}
		else if (singleObjectData.worldPosition_.y > CameraPos.y)
		{
			continue;
		}
		else if (singleObjectData.worldPosition_.y < CameraPos.y - 2560.f)
		{
			continue;

		}
		if (singleObjectData.worldPosition_.z > CameraPos.z + 1500.f)
		{
			continue;
		}
		else if (singleObjectData.worldPosition_.z < CameraPos.z)
		{
			continue;
		}

		renderingFieldObjectDataVector_.push_back(&singleObjectData);
	}

	for (size_t i = static_cast<size_t>(tileCount_); i < worldRenderer_->GetUnitCount(); i++)
	{
		worldRenderer_->GetInstancingUnit(i).SetWorldScale(
			float4::Zero
		);
	}

	int objectIndex = 0;

	for (size_t unitIndex = static_cast<size_t>(tileCount_);
		unitIndex < worldRenderer_->GetUnitCount(); ++unitIndex)
	{
		if (objectIndex >= renderingFieldObjectDataVector_.size())
		{
			break;
		}
		worldRenderer_->GetInstancingUnit(unitIndex).SetWorldScale(
			renderingFieldObjectDataVector_[objectIndex]->worldScale_
		);

		worldRenderer_->GetInstancingUnit(unitIndex).SetWorldPosition(
			renderingFieldObjectDataVector_[objectIndex]->worldPosition_
		);
		
		worldRenderer_->GetInstancingUnit(unitIndex).GetAtlasData().SetData(
			worldObjectAtlasDatas_[renderingFieldObjectDataVector_[objectIndex]->atlasDataIndex_]
		);
		

		worldRenderer_->GetInstancingUnit(unitIndex).SetTextureIndex(3);


		++objectIndex;
	}




#ifdef _DEBUG
	if (objectIndex < renderingFieldObjectDataVector_.size())
	{
		MsgBoxAssert("인스턴싱유닛의 숫자가 모자라서 필드 오브젝트들을 다 그리지 못했습니다.");
		return;
	}
	//릴리즈모드에서 이런 일이 생기면 그냥 무시하고 진행한다.
#endif // DEBUG

}